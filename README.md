# ОБОБЩЕННЫЕ И ДВОЙНЫЕ ОБОБЩЁННЫЕ ГРАФЫ ПЕТЕРСЕНА. РЕАЛИЗАЦИЯ АЛГОРИТМОВ.

## Введение
        Графы играют ключевую роль в различных областях математики и компьютерных наук, находя применение в теории сетей, оптимизации, алгоритмах и моделировании реальных систем. Особое место среди них занимают обобщенные графы Петерсена и их двойные аналоги, которые представляют собой важные классы регулярных графов с уникальными структурными свойствами.

        Обобщенные графы Петерсена P(n, k) были впервые введены и описаны Д. Петерсеном в 1898 году. Каждый такой граф определяется двумя параметрами n и k, где n — это количество вершин в графе, а k — шаг, используемый для соединения вершин. Эти графы демонстрируют интересные комбинаторные и топологические характеристики, которые делают их привлекательными для исследований в теории графов.

        Двойные обобщенные графы Петерсена являются расширением этой концепции. Они строятся на основе двух обобщенных графов Петерсена, соединенных определенным образом, что добавляет уровень сложности и разнообразия в их структуру. Эти графы находят применение в задачах оптимизации сетей, в моделировании коммуникационных систем и в теории кодирования.

## Постановка задачи
        Цель данной научной работы — исследовать свойства обобщенных графов Петерсена и их двойных аналогов, изучить их комбинаторные и структурные особенности, а также рассмотреть потенциальные области применения. В ходе работы будут проанализированы основные алгоритмы построения таких графов, также будут реализованы алгоритмы BFS, DFS и алгоритмы раскраски этих классов графов. 

        Изучение этих графов позволяет углубить понимание регулярных структур в графах, выявить новые закономерности и разработать эффективные методы анализа и применения в различных научных и инженерных областях.

## 1.	Обобщенные графы Петерсена
        Обобщенные графы Петерсена P(n, k) были впервые введены и описаны Д. Петерсеном в 1898 году. Каждый такой граф определяется двумя параметрами n и k, где n — это количество вершин в графе, а k — шаг, используемый для соединения вершин. Эти графы демонстрируют интересные комбинаторные и топологические характеристики, которые делают их привлекательными для исследований в теории графов. 

        Пусть n и k - целые числа, причем n ≥ 2k + 1 ≥ 3. Множество вершин обобщенного графа Петерсена P(n, k) - это {u1, u2, • • •, un} ∪ {v1, v2, • • •, vn}. Рёбра графа P(n, k) представлены как uiui+1, uivi, vivi+k для 1 ≤ i ≤ n, где индексы вычисляются по модулю n. Стоит отметить, что обобщенные графы Петерсена являются 3-регулярными графами, то есть каждая вершина имеет степень 3.

## 2.	Двойные обобщенные графы Петерсена
        Кутнар и Петецки предложили двойные обобщенные графы Петерсена и изучили их автоморфизмы и структурные свойства. Они строятся на основе двух обобщенных графов Петерсена, соединенных определенным образом, что добавляет уровень сложности и разнообразия в их структуру. Эти графы находят применение в задачах оптимизации сетей, в моделировании коммуникационных систем и в теории кодирования.
        Для заданного целого числа n ≥ 3 и 1 ≤ k ≤ n − 1 двойной обобщенный граф Петерсена DP(n, k) имеет множество вершин
        V(DP(n,k)) = {xi,yi,ui,vi | i ∈ [n]}
        а его множество рёбер - объединение E(DP(n, k)) = E1 ∪ E2 ∪ E3, где

        E1 = {{yi, yi+1}, {xi, xi+1} | i ∈ [n]},
        E2 = {{xi, ui}, {yi, vi} | i ∈ [n]},
        E3 = {{vi, ui+k}, {ui, vi+k} | i ∈ [n]},

        а индексы уменьшаются по модулю n 
## 3.	Раскраска графа и хроматическое число
### Раскраска графа
        Раскраска графа — это задача, в которой каждой вершине графа присваивается цвет таким образом, чтобы никакие две смежные вершины не имели одинакового цвета. Целью раскраски графа является использование минимального количества цветов, чтобы удовлетворить это условие. Раскраска графов имеет широкое применение в реальной жизни, например, в задачах планировании, распределения ресурсов и частот, и в задачах оптимизации.

        Процесс раскраски графа можно формально описать следующим образом:
        1.	Даны граф G = (V, E), где V – множество вершин, а E – множество рёбер.
        2.	Требуется найти функцию c: V → {1, 2, …, k}, где k -  минимально возможное число цветов, такая, что для любых двух смежных вершин u и v выполнено c(u) ≠ c(v).
### Хроматическое число
        Хроматическое число графа G, обозначаемое χ(G), — это минимальное количество цветов, необходимое для раскраски графа. Определение хроматического числа является NP-трудной задачей, что делает её вычислительно сложной, особенно для больших графов. 

        Например, граф Петерсена нельзя правильно раскрасить в два цвета, поскольку в нём есть циклы нечётной длины. Следовательно, его хроматическое число равно 3.

        На практике используются различные эвристические и приближенные методы для нахождения раскраски, близкой к оптимальной. 

## 4.	Поиск в глубину (DFS) и поиск в ширину (BFS)
        Поиск в глубину (DFS) — это алгоритм обхода или поиска в графе, который начинается с произвольной стартовой вершины и исследует как можно дальше вдоль каждого пути, прежде чем вернуться назад. 

#### Описание DFS:
        1.	Начинается с начальной вершины, которая помечается как посещенная.
        2.	Рекурсивно посещаются все смежные непосещённые вершины.
        3.	Возвращение назад происходит только после того, как все смежные вершины текущей вершины были посещены.

#### Особенности DFS:
        •	Работает на основе стека (может быть реализован с помощью рекурсии или явного стека).
        •	Подходит для задач, требующих полного исследования всех путей в графе.
        •	Используется для проверки связности графа, нахождения всех компонент связности, обнаружения циклов, и других задач.

#### Анализ сложности DFS:
        •	Временная сложность: O(V + E), где V — количество вершин, а E — количество ребер в графе.
        •	Вспомогательное пространство: O(V + E), поскольку требуется дополнительный посещаемый массив размером V, и размер стека для итеративного вызова функции DFS.

        Поиск в ширину (BFS) — это алгоритм обхода или поиска в графе, который начинается с произвольной стартовой вершины и исследует все её соседние вершины перед переходом к вершинам следующего уровня. 

#### Описание BFS:
        1.	Начинается с начальной вершины, которая добавляется в очередь и помечается как посещенная.
        2.	Выталкивается первая вершина из очереди и исследуются все её непосещённые соседние вершины, которые затем добавляются в очередь.
        3.	Процесс продолжается до тех пор, пока очередь не станет пустой.

#### Особенности BFS:
        •	Работает на основе очереди.
        •	Подходит для нахождения кратчайшего пути в невзвешенных графах.
        •	Используется для определения уровня вершин, радиуса, диаметра и эксцентриситета графа.

#### Анализ сложности BFS:
        •	Временная сложность: O(V + E), где V — количество вершин, а E — количество ребер в графе.
        •	Вспомогательное пространство: O(V), поскольку требуется очередь размером V и массив для отметки посещенных вершин размером V.

## 5.	Программная реализация
        Изучив необходимый материал, я приступил к реализации консольной версии программы, в которой бы осуществлялось создание обобщённых графов Петерсена и двойных обобщённых графов Петерсена, а также алгоритмов раскраски, нахождения хроматического числа, DFS и BFS.

        Рассмотрим подробнее каждый из модулей:
#### Matrix.h
        Представляет собой класс Matrix, который содержит в себе количество строк и столбцов матрицы, а также двумерный вектор, который представляет собой матрицу.
        Класс содержит необходимые для работы с ним конструкторы, геттеры количества строк, столбцов, самой матрицы, столбца, строки и искомого элемента по строке и столбцу. Также имеется сеттер элемента по строке и столбцу. Помимо этого, были реализованы методы заполнения всей матрицы заданным значением, добавления в матрицу строки, столбца с заданным значением и удаления строки или столбца по номеру. В классе перегружены операторы +, -, =, а также операторы ввода и вывода (<<, >>).
#### Graph.h
        Представляет собой класс Graph, который содержит в себе матрицу смежности графа, количество вершин и количество рёбер графа. 
        Класс содержит необходимые для работы с ним конструкторы, геттеры матрицы смежности, количества вершин и рёбер, а также вектора вершин, смежных с заданной, сеттеры матрицы смежности и количества вершин в графе. Важными методами в классе являются методы добавления и удаления вершин и рёбер. В классе имеется перегрузка оператора присваивания, с различными входными параметрами (граф или матрица с булевыми значениями), и обязательно операторы ввода и вывода графа.
#### UndirectedGraph.h
        От класса Graph наследуется класс UndirectedGraph, который представляет из себя неориентированный граф. В нём реализованы некоторые конструкторы, а также важная деталь, отличающая неориентированный граф от ориентированного – методы добавления и удаления рёбер.
#### GeneralizedPetersenGraph.h
        Класс GeneralizedPetersenGraph представляет собой обобщённый граф Петерсена. Он содержит в себе поле типа UndirectedGraph и параметры n и k, присущие данному графу. У класса имеется конструктор по умолчанию, а также конструктор, принимающий параметры n и k. В этом конструкторе происходит создание графа путём присвоения ему 2 * n вершин и последующее соединение этих вершин по определённым правилам. Для удобного пользования класс содержит в себе геттеры графа UndirectedGraph и имени, которое имеет следующий вид – “P(n, k)”.
#### DoubleGeneralizedPetersenGraph.h
        Класс DoubleGeneralizedPetersenGraph представляет собой двойной обобщённый граф Петерсена. Он, аналогично простому обобщённому графу Петерсена, содержит в себе неориентированный граф и значения n и k. Аналогично, в нём имеется конструктор по умолчанию и конструктор, в котором происходит заполнение матрицы смежности графа, следуя определённым правилам соединения вершин рёбрами. И также для удобства пользования, имеется геттер графа и имени графа – “DP(n, k)”.
#### Algorithms.h
        Этот модуль является важной частью проекта, так как в нём содержаться все основные реализованные алгоритмы. Файл содержит в себе жадный алгоритм раскраски графа, метод получения хроматического числа для графа и алгоритмы BFS и DFS. Так же я добавил алгоритм, который находит все возможные обобщённые и двойные обобщённые графы Петерсена по заданному хроматическому числу и параметру n. Алгоритмы, в свою очередь, находятся в пространстве имён alg.
 
#### Результат
        В результате получилась программа, которая может построить матрицу смежности для обобщённого и двойного обобщённого графа Петерсена и применить к ним все алгоритмы, описанные в библиотеке Algorithms.h.

## Заключение
        Разработка алгоритмов раскраски графа, определения хроматического числа, а также алгоритмов обхода графа в глубину (DFS) и в ширину (BFS) на языке C++ для обобщенных графов Петерсена и двойных обобщённых графов Петерсена предоставляет исследователям мощные инструменты для анализа и исследования этих уникальных структур. Эти алгоритмы не только позволяют глубже понять свойства графов, но и находят широкое применение в различных практических задачах, таких как планирование, распределение ресурсов и оптимизация сетей.

        Таким образом, применение этих алгоритмов для обобщенных графов Петерсена и их двойных аналогов способствует углубленному изучению и пониманию теоретических аспектов теории графов. Кроме того, оно открывает широкие возможности для решения практических задач в различных областях, таких как планирование, распределение ресурсов, оптимизация сетей и многие другие.

